def __test_int_arith() {
    assert_eq(1, 1)
    assert(!(1 == 2))
    assert(1 != 2)

    assert_eq(5 + 3, 8)
    assert_eq(5 * 3, 15)
    assert_eq(5 / 2, 2.5)
    assert_eq(5 // 2, 2)
    assert_eq(5 % 3, 2)
}

def __test_negative_truncdiv_and_remainder() {
    """
    Mirror what Rust does
    """
    assert_eq((-5) % (3), -2)
    assert_eq((5) % (-3), 2)
    assert_eq((-5) % (-3), -2)
    assert_eq((-5) // (3), -1)
    assert_eq((5) // (-3), -1)
    assert_eq((-5) // (-3), 1)
}

def __test_negative_floordiv_and_mod() {
    """
    Results here should mirror what Python does
    """
    assert_eq((-5).mod(3), 1)
    assert_eq((5).mod(-3), -1)
    assert_eq((-5).mod(-3), -2)
    assert_eq((-5).fdiv(3), -2)
    assert_eq((5).fdiv(-3), -2)
    assert_eq((-5).fdiv(-3), 1)
}

def __test_div_consistency() {
    for [a, b] in [[-5, 3], [5, -3], [-5, -3]] {
        assert_eq(a.divrem(b), [a // b, a % b])
        assert_eq(a.divrem(b), [a.tdiv(b), a.rem(b)])
        assert_eq(a.divmod(b), [a.fdiv(b), a.mod(b)])
    }
}

def __test_int_float_mixed_arithmetic() {
    assert(1.0 + 1.0 is 2.0)
    assert(1.0 + 1 is 2.0)
    assert(1 + 1.0 is 2.0)

    assert(4.0 - 1.0 is 3.0)
    assert(4.0 - 1 is 3.0)
    assert(4 - 1.0 is 3.0)

    assert(4.0 * 2.0 is 8.0)
    assert(4.0 * 2 is 8.0)
    assert(4 * 2.0 is 8.0)

    assert(5.0 / 2.0 is 2.5)
    assert(5 / 2.0 is 2.5)
    assert(5.0 / 2 is 2.5)

    assert(5.0 // 2 is 2)
    assert(5.0 // 2.1 is 2)
}
